/*
 * generated by Xtext 2.25.0
 */
package fr.irisa.serializer;

import com.google.inject.Inject;
import fr.irisa.dslCsv.Acquire;
import fr.irisa.dslCsv.ArithExpression;
import fr.irisa.dslCsv.Assign;
import fr.irisa.dslCsv.Column;
import fr.irisa.dslCsv.CompExpression;
import fr.irisa.dslCsv.ConstNat;
import fr.irisa.dslCsv.ConstStr;
import fr.irisa.dslCsv.ConstVector;
import fr.irisa.dslCsv.Count;
import fr.irisa.dslCsv.Dim;
import fr.irisa.dslCsv.DslCsvPackage;
import fr.irisa.dslCsv.Features;
import fr.irisa.dslCsv.Filter;
import fr.irisa.dslCsv.LogicalExpression;
import fr.irisa.dslCsv.Mean;
import fr.irisa.dslCsv.Nop;
import fr.irisa.dslCsv.Parenthesis;
import fr.irisa.dslCsv.Print;
import fr.irisa.dslCsv.Product;
import fr.irisa.dslCsv.Program;
import fr.irisa.dslCsv.Row;
import fr.irisa.dslCsv.Save;
import fr.irisa.dslCsv.Select;
import fr.irisa.dslCsv.Sort;
import fr.irisa.dslCsv.SubExpression;
import fr.irisa.dslCsv.Sum;
import fr.irisa.dslCsv.Unselect;
import fr.irisa.dslCsv.Var;
import fr.irisa.services.DslCsvGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DslCsvSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DslCsvGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DslCsvPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DslCsvPackage.ACQUIRE:
				sequence_Acquire(context, (Acquire) semanticObject); 
				return; 
			case DslCsvPackage.ARITH_EXPRESSION:
				sequence_ArithExpression(context, (ArithExpression) semanticObject); 
				return; 
			case DslCsvPackage.ASSIGN:
				sequence_Assign(context, (Assign) semanticObject); 
				return; 
			case DslCsvPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case DslCsvPackage.COMP_EXPRESSION:
				sequence_CompExpression(context, (CompExpression) semanticObject); 
				return; 
			case DslCsvPackage.CONST_NAT:
				sequence_ConstNat(context, (ConstNat) semanticObject); 
				return; 
			case DslCsvPackage.CONST_STR:
				sequence_ConstStr(context, (ConstStr) semanticObject); 
				return; 
			case DslCsvPackage.CONST_VECTOR:
				sequence_ConstVector(context, (ConstVector) semanticObject); 
				return; 
			case DslCsvPackage.COUNT:
				sequence_Count(context, (Count) semanticObject); 
				return; 
			case DslCsvPackage.DIM:
				sequence_Dim(context, (Dim) semanticObject); 
				return; 
			case DslCsvPackage.FEATURES:
				sequence_Features(context, (Features) semanticObject); 
				return; 
			case DslCsvPackage.FILTER:
				sequence_Filter(context, (Filter) semanticObject); 
				return; 
			case DslCsvPackage.LOGICAL_EXPRESSION:
				sequence_LogicalExpression(context, (LogicalExpression) semanticObject); 
				return; 
			case DslCsvPackage.MEAN:
				sequence_Mean(context, (Mean) semanticObject); 
				return; 
			case DslCsvPackage.NOP:
				sequence_Nop(context, (Nop) semanticObject); 
				return; 
			case DslCsvPackage.PARENTHESIS:
				sequence_Parenthesis(context, (Parenthesis) semanticObject); 
				return; 
			case DslCsvPackage.PRINT:
				sequence_Print(context, (Print) semanticObject); 
				return; 
			case DslCsvPackage.PRODUCT:
				sequence_Product(context, (Product) semanticObject); 
				return; 
			case DslCsvPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case DslCsvPackage.ROW:
				sequence_Row(context, (Row) semanticObject); 
				return; 
			case DslCsvPackage.SAVE:
				sequence_Save(context, (Save) semanticObject); 
				return; 
			case DslCsvPackage.SELECT:
				sequence_Select(context, (Select) semanticObject); 
				return; 
			case DslCsvPackage.SORT:
				sequence_Sort(context, (Sort) semanticObject); 
				return; 
			case DslCsvPackage.SUB_EXPRESSION:
				sequence_SubExpression(context, (SubExpression) semanticObject); 
				return; 
			case DslCsvPackage.SUM:
				sequence_Sum(context, (Sum) semanticObject); 
				return; 
			case DslCsvPackage.UNSELECT:
				sequence_Unselect(context, (Unselect) semanticObject); 
				return; 
			case DslCsvPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns Acquire
	 *     FuncCall returns Acquire
	 *     Acquire returns Acquire
	 *
	 * Constraint:
	 *     (path=Expression sep=Expression hasHeader=Expression)
	 */
	protected void sequence_Acquire(ISerializationContext context, Acquire semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.ACQUIRE__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.ACQUIRE__PATH));
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.ACQUIRE__SEP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.ACQUIRE__SEP));
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.ACQUIRE__HAS_HEADER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.ACQUIRE__HAS_HEADER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAcquireAccess().getPathExpressionParserRuleCall_2_0(), semanticObject.getPath());
		feeder.accept(grammarAccess.getAcquireAccess().getSepExpressionParserRuleCall_4_0(), semanticObject.getSep());
		feeder.accept(grammarAccess.getAcquireAccess().getHasHeaderExpressionParserRuleCall_6_0(), semanticObject.getHasHeader());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithExpression returns ArithExpression
	 *
	 * Constraint:
	 *     (left=SubExpression ((op='+' | op='-') right=ArithExpression)?)
	 */
	protected void sequence_ArithExpression(ISerializationContext context, ArithExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Assign
	 *     Assign returns Assign
	 *
	 * Constraint:
	 *     (var=ID val=Expression)
	 */
	protected void sequence_Assign(ISerializationContext context, Assign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.ASSIGN__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.ASSIGN__VAR));
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.ASSIGN__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.ASSIGN__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignAccess().getVarIDTerminalRuleCall_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getAssignAccess().getValExpressionParserRuleCall_2_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Column
	 *     FuncCall returns Column
	 *     Column returns Column
	 *
	 * Constraint:
	 *     (file=Expression columnName=Expression vector=Expression)
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.COLUMN__FILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.COLUMN__FILE));
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.COLUMN__COLUMN_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.COLUMN__COLUMN_NAME));
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.COLUMN__VECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.COLUMN__VECTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnAccess().getFileExpressionParserRuleCall_2_0(), semanticObject.getFile());
		feeder.accept(grammarAccess.getColumnAccess().getColumnNameExpressionParserRuleCall_4_0(), semanticObject.getColumnName());
		feeder.accept(grammarAccess.getColumnAccess().getVectorExpressionParserRuleCall_6_0(), semanticObject.getVector());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompExpression returns CompExpression
	 *
	 * Constraint:
	 *     (
	 *         left=ArithExpression 
	 *         (
	 *             (
	 *                 op='<' | 
	 *                 op='>' | 
	 *                 op='==' | 
	 *                 op='<=' | 
	 *                 op='>=' | 
	 *                 op='!='
	 *             ) 
	 *             right=CompExpression
	 *         )?
	 *     )
	 */
	protected void sequence_CompExpression(ISerializationContext context, CompExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BaseExpression returns ConstNat
	 *     ConstNat returns ConstNat
	 *
	 * Constraint:
	 *     constNat=INT
	 */
	protected void sequence_ConstNat(ISerializationContext context, ConstNat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.CONST_NAT__CONST_NAT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.CONST_NAT__CONST_NAT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstNatAccess().getConstNatINTTerminalRuleCall_0(), semanticObject.getConstNat());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BaseExpression returns ConstStr
	 *     ConstStr returns ConstStr
	 *
	 * Constraint:
	 *     constStr=STRING
	 */
	protected void sequence_ConstStr(ISerializationContext context, ConstStr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.CONST_STR__CONST_STR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.CONST_STR__CONST_STR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstStrAccess().getConstStrSTRINGTerminalRuleCall_0(), semanticObject.getConstStr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BaseExpression returns ConstVector
	 *     ConstVector returns ConstVector
	 *
	 * Constraint:
	 *     (constVector+=Expression constVector+=Expression*)
	 */
	protected void sequence_ConstVector(ISerializationContext context, ConstVector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Count
	 *     FuncCall returns Count
	 *     Count returns Count
	 *
	 * Constraint:
	 *     vector=Expression
	 */
	protected void sequence_Count(ISerializationContext context, Count semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.COUNT__VECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.COUNT__VECTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCountAccess().getVectorExpressionParserRuleCall_2_0(), semanticObject.getVector());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Dim
	 *     FuncCall returns Dim
	 *     Dim returns Dim
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_Dim(ISerializationContext context, Dim semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.DIM__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.DIM__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDimAccess().getExprExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Features
	 *     FuncCall returns Features
	 *     Features returns Features
	 *
	 * Constraint:
	 *     file=Expression
	 */
	protected void sequence_Features(ISerializationContext context, Features semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.FEATURES__FILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.FEATURES__FILE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeaturesAccess().getFileExpressionParserRuleCall_2_0(), semanticObject.getFile());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Filter
	 *     FuncCall returns Filter
	 *     Filter returns Filter
	 *
	 * Constraint:
	 *     (file=Expression cond=Expression)
	 */
	protected void sequence_Filter(ISerializationContext context, Filter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.FILTER__FILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.FILTER__FILE));
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.FILTER__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.FILTER__COND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFilterAccess().getFileExpressionParserRuleCall_2_0(), semanticObject.getFile());
		feeder.accept(grammarAccess.getFilterAccess().getCondExpressionParserRuleCall_4_0(), semanticObject.getCond());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LogicalExpression
	 *     LogicalExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (left=CompExpression ((op='|' | op='&') right=LogicalExpression)?)
	 */
	protected void sequence_LogicalExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Mean
	 *     FuncCall returns Mean
	 *     Mean returns Mean
	 *
	 * Constraint:
	 *     vector=Expression
	 */
	protected void sequence_Mean(ISerializationContext context, Mean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.MEAN__VECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.MEAN__VECTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMeanAccess().getVectorExpressionParserRuleCall_2_0(), semanticObject.getVector());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Nop
	 *     Nop returns Nop
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_Nop(ISerializationContext context, Nop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.NOP__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.NOP__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNopAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BaseExpression returns Parenthesis
	 *     Parenthesis returns Parenthesis
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_Parenthesis(ISerializationContext context, Parenthesis semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.PARENTHESIS__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.PARENTHESIS__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParenthesisAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Print
	 *     FuncCall returns Print
	 *     Print returns Print
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_Print(ISerializationContext context, Print semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.PRINT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.PRINT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintAccess().getExprExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Product
	 *     FuncCall returns Product
	 *     Product returns Product
	 *
	 * Constraint:
	 *     vector=Expression
	 */
	protected void sequence_Product(ISerializationContext context, Product semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.PRODUCT__VECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.PRODUCT__VECTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProductAccess().getVectorExpressionParserRuleCall_2_0(), semanticObject.getVector());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (expr+=Expression expr+=Expression*)
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Row
	 *     FuncCall returns Row
	 *     Row returns Row
	 *
	 * Constraint:
	 *     (file=Expression vector=Expression)
	 */
	protected void sequence_Row(ISerializationContext context, Row semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.ROW__FILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.ROW__FILE));
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.ROW__VECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.ROW__VECTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRowAccess().getFileExpressionParserRuleCall_2_0(), semanticObject.getFile());
		feeder.accept(grammarAccess.getRowAccess().getVectorExpressionParserRuleCall_4_0(), semanticObject.getVector());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Save
	 *     FuncCall returns Save
	 *     Save returns Save
	 *
	 * Constraint:
	 *     (filename=Expression file=Expression sep=Expression saveHeader=Expression saveID=Expression)
	 */
	protected void sequence_Save(ISerializationContext context, Save semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.SAVE__FILENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.SAVE__FILENAME));
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.SAVE__FILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.SAVE__FILE));
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.SAVE__SEP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.SAVE__SEP));
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.SAVE__SAVE_HEADER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.SAVE__SAVE_HEADER));
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.SAVE__SAVE_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.SAVE__SAVE_ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSaveAccess().getFilenameExpressionParserRuleCall_2_0(), semanticObject.getFilename());
		feeder.accept(grammarAccess.getSaveAccess().getFileExpressionParserRuleCall_4_0(), semanticObject.getFile());
		feeder.accept(grammarAccess.getSaveAccess().getSepExpressionParserRuleCall_6_0(), semanticObject.getSep());
		feeder.accept(grammarAccess.getSaveAccess().getSaveHeaderExpressionParserRuleCall_8_0(), semanticObject.getSaveHeader());
		feeder.accept(grammarAccess.getSaveAccess().getSaveIDExpressionParserRuleCall_10_0(), semanticObject.getSaveID());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Select
	 *     FuncCall returns Select
	 *     Select returns Select
	 *
	 * Constraint:
	 *     (file=Expression features=Expression)
	 */
	protected void sequence_Select(ISerializationContext context, Select semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.SELECT__FILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.SELECT__FILE));
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.SELECT__FEATURES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.SELECT__FEATURES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectAccess().getFileExpressionParserRuleCall_2_0(), semanticObject.getFile());
		feeder.accept(grammarAccess.getSelectAccess().getFeaturesExpressionParserRuleCall_4_0(), semanticObject.getFeatures());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Sort
	 *     FuncCall returns Sort
	 *     Sort returns Sort
	 *
	 * Constraint:
	 *     (file=Expression criterion=Expression)
	 */
	protected void sequence_Sort(ISerializationContext context, Sort semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.SORT__FILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.SORT__FILE));
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.SORT__CRITERION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.SORT__CRITERION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSortAccess().getFileExpressionParserRuleCall_2_0(), semanticObject.getFile());
		feeder.accept(grammarAccess.getSortAccess().getCriterionExpressionParserRuleCall_4_0(), semanticObject.getCriterion());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SubExpression returns SubExpression
	 *
	 * Constraint:
	 *     (left=BaseExpression ((op='*' | op='/' | op='%') right=SubExpression)?)
	 */
	protected void sequence_SubExpression(ISerializationContext context, SubExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Sum
	 *     FuncCall returns Sum
	 *     Sum returns Sum
	 *
	 * Constraint:
	 *     vector=Expression
	 */
	protected void sequence_Sum(ISerializationContext context, Sum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.SUM__VECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.SUM__VECTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSumAccess().getVectorExpressionParserRuleCall_2_0(), semanticObject.getVector());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Unselect
	 *     FuncCall returns Unselect
	 *     Unselect returns Unselect
	 *
	 * Constraint:
	 *     (file=Expression features=Expression)
	 */
	protected void sequence_Unselect(ISerializationContext context, Unselect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.UNSELECT__FILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.UNSELECT__FILE));
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.UNSELECT__FEATURES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.UNSELECT__FEATURES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnselectAccess().getFileExpressionParserRuleCall_2_0(), semanticObject.getFile());
		feeder.accept(grammarAccess.getUnselectAccess().getFeaturesExpressionParserRuleCall_4_0(), semanticObject.getFeatures());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BaseExpression returns Var
	 *     Var returns Var
	 *
	 * Constraint:
	 *     var=ID
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslCsvPackage.Literals.VAR__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslCsvPackage.Literals.VAR__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarAccess().getVarIDTerminalRuleCall_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
}
