package fr.irisa.generator;

import fr.irisa.dslCsv.Acquire;
import fr.irisa.dslCsv.ArithExpression;
import fr.irisa.dslCsv.Assign;
import fr.irisa.dslCsv.BaseExpression;
import fr.irisa.dslCsv.Column;
import fr.irisa.dslCsv.CompExpression;
import fr.irisa.dslCsv.ConstNat;
import fr.irisa.dslCsv.ConstStr;
import fr.irisa.dslCsv.ConstVector;
import fr.irisa.dslCsv.Count;
import fr.irisa.dslCsv.Dim;
import fr.irisa.dslCsv.Expression;
import fr.irisa.dslCsv.Features;
import fr.irisa.dslCsv.Filter;
import fr.irisa.dslCsv.FuncCall;
import fr.irisa.dslCsv.LogicalExpression;
import fr.irisa.dslCsv.Mean;
import fr.irisa.dslCsv.Nop;
import fr.irisa.dslCsv.Parenthesis;
import fr.irisa.dslCsv.Print;
import fr.irisa.dslCsv.Product;
import fr.irisa.dslCsv.Row;
import fr.irisa.dslCsv.Save;
import fr.irisa.dslCsv.Select;
import fr.irisa.dslCsv.Sort;
import fr.irisa.dslCsv.SubExpression;
import fr.irisa.dslCsv.Sum;
import fr.irisa.dslCsv.Unselect;
import fr.irisa.dslCsv.Var;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

@SuppressWarnings("all")
public class ASTtoBash {
  private static final int FUNC_CALL_NUMBER = 15;
  
  /**
   * used to know wich ones of the function are used,
   * and need to be implemented in the compiled program
   */
  private static Set<String> isFuncCalled = new HashSet<String>(ASTtoBash.FUNC_CALL_NUMBER);
  
  /**
   * list of bash instructions generated by the compilation
   */
  private static String generated_header = "#!/bin/bash\nfolder=$(mktemp -d)+\"/\"\n";
  
  private static String generated_code = "\n";
  
  /**
   * keeps track of the types of variables
   */
  private static Map<String, type> symboltable = new HashMap<String, type>();
  
  /**
   * stacks the arguments of function calls
   */
  private static Stack<String> argStack = new Stack<String>();
  
  private static int file_id = 0;
  
  private static type env = type.VOID;
  
  public <T extends Object> T pop(final EList<T> l) {
    T _xifexpression = null;
    int _size = l.size();
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      T _xblockexpression = null;
      {
        final T tmp = l.get(0);
        l.remove(0);
        _xblockexpression = tmp;
      }
      _xifexpression = _xblockexpression;
    } else {
      _xifexpression = null;
    }
    return _xifexpression;
  }
  
  public String newFile() {
    int _plusPlus = ASTtoBash.file_id++;
    String _plus = ("csv" + Integer.valueOf(_plusPlus));
    return (_plus + ".csv");
  }
  
  public String eval(final EList<Expression> l) {
    String _xblockexpression = null;
    {
      final Consumer<Expression> _function = (Expression it) -> {
        this.eval(it);
      };
      l.forEach(_function);
      String _implemFunction = this.implemFunction();
      String _plus = (ASTtoBash.generated_header + _implemFunction);
      String _plus_1 = (_plus + ASTtoBash.generated_code);
      _xblockexpression = (_plus_1 + "\nrm -r ${folder::-1}");
    }
    return _xblockexpression;
  }
  
  public void eval(final Expression e) {
    try {
      if ((e instanceof FuncCall)) {
        this.evalFunc(((FuncCall) e));
      } else {
        if ((e instanceof Assign)) {
          this.eval(((Assign) e).getVal());
          final String ev = ASTtoBash.argStack.pop();
          boolean _equals = ASTtoBash.env.equals(type.FILE);
          if (_equals) {
            String _generated_code = ASTtoBash.generated_code;
            String _var = ((Assign) e).getVar();
            String _plus = ((("echo " + ev) + " > ") + _var);
            String _plus_1 = (_plus + "\n");
            ASTtoBash.generated_code = (_generated_code + _plus_1);
          } else {
            String _generated_code_1 = ASTtoBash.generated_code;
            String _var_1 = ((Assign) e).getVar();
            String _plus_2 = (_var_1 + "=");
            String _plus_3 = (_plus_2 + ev);
            String _plus_4 = (_plus_3 + "\n");
            ASTtoBash.generated_code = (_generated_code_1 + _plus_4);
          }
          ASTtoBash.symboltable.put(((Assign) e).getVar(), ASTtoBash.env);
        } else {
          if ((e instanceof LogicalExpression)) {
            this.eval(((LogicalExpression) e));
          } else {
            if ((e instanceof Nop)) {
              this.eval(((Nop) e).getExpr());
              boolean _equals_1 = ASTtoBash.env.equals(type.FILE);
              if (_equals_1) {
                throw new TypeException(ASTtoBash.env, type.NEGATION);
              }
              String _pop = ASTtoBash.argStack.pop();
              String _plus_5 = ("$[ ! " + _pop);
              String _plus_6 = (_plus_5 + " ]");
              ASTtoBash.argStack.push(_plus_6);
            }
          }
        }
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public void eval(final LogicalExpression e) {
    try {
      this.eval(e.getLeft());
      String _op = e.getOp();
      boolean _tripleNotEquals = (_op != null);
      if (_tripleNotEquals) {
        final type t1 = ASTtoBash.env;
        this.eval(e.getRight());
        final type t2 = ASTtoBash.env;
        boolean _equals = t1.equals(t2);
        boolean _not = (!_equals);
        if (_not) {
          throw new TypeException(t1, t2);
        }
        final String r = ASTtoBash.argStack.pop();
        final String l = ASTtoBash.argStack.pop();
        String _op_1 = e.getOp();
        String _plus = (l + _op_1);
        String _plus_1 = (_plus + r);
        ASTtoBash.argStack.push(_plus_1);
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public void eval(final CompExpression e) {
    try {
      this.eval(e.getLeft());
      String _op = e.getOp();
      boolean _tripleNotEquals = (_op != null);
      if (_tripleNotEquals) {
        final type t1 = ASTtoBash.env;
        this.eval(e.getRight());
        final type t2 = ASTtoBash.env;
        boolean _equals = t1.equals(t2);
        boolean _not = (!_equals);
        if (_not) {
          throw new TypeException(t1, t2);
        }
        final String r = ASTtoBash.argStack.pop();
        final String l = ASTtoBash.argStack.pop();
        String _op_1 = e.getOp();
        String _plus = (l + _op_1);
        String _plus_1 = (_plus + r);
        ASTtoBash.argStack.push(_plus_1);
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public void eval(final ArithExpression e) {
    try {
      this.eval(e.getLeft());
      String _op = e.getOp();
      boolean _tripleNotEquals = (_op != null);
      if (_tripleNotEquals) {
        final type t1 = ASTtoBash.env;
        this.eval(e.getRight());
        final type t2 = ASTtoBash.env;
        boolean _equals = t1.equals(t2);
        boolean _not = (!_equals);
        if (_not) {
          throw new TypeException(t1, t2);
        }
        final String r = ASTtoBash.argStack.pop();
        final String l = ASTtoBash.argStack.pop();
        String _op_1 = e.getOp();
        String _plus = (l + _op_1);
        String _plus_1 = (_plus + r);
        ASTtoBash.argStack.push(_plus_1);
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public void eval(final SubExpression e) {
    try {
      this.evalExpr(e.getLeft());
      String _op = e.getOp();
      boolean _tripleNotEquals = (_op != null);
      if (_tripleNotEquals) {
        final type t1 = ASTtoBash.env;
        this.eval(e.getRight());
        final type t2 = ASTtoBash.env;
        boolean _equals = t1.equals(t2);
        boolean _not = (!_equals);
        if (_not) {
          throw new TypeException(t1, t2);
        }
        final String r = ASTtoBash.argStack.pop();
        final String l = ASTtoBash.argStack.pop();
        String _op_1 = e.getOp();
        String _plus = (l + _op_1);
        String _plus_1 = (_plus + r);
        ASTtoBash.argStack.push(_plus_1);
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  protected void _evalExpr(final Var e) {
    final String v = e.getVar();
    ASTtoBash.argStack.push(v);
    ASTtoBash.env = ASTtoBash.symboltable.get(v);
  }
  
  protected void _evalExpr(final ConstNat e) {
    ASTtoBash.argStack.push(String.valueOf(e.getConstNat()));
    ASTtoBash.env = type.INT;
  }
  
  protected void _evalExpr(final ConstStr e) {
    ASTtoBash.argStack.push(e.getConstStr());
    ASTtoBash.env = type.STRING;
  }
  
  protected void _evalExpr(final ConstVector e) {
    String _newFile = this.newFile();
    String _plus = ("$folder+\"" + _newFile);
    final String f = (_plus + "\"");
    String _generated_code = ASTtoBash.generated_code;
    final Function2<String, Expression, String> _function = (String s, Expression x) -> {
      String _xblockexpression = null;
      {
        this.eval(x);
        String _xifexpression = null;
        boolean _equals = ASTtoBash.env.equals(type.FILE);
        if (_equals) {
          String _pop = ASTtoBash.argStack.pop();
          String _plus_1 = ((s + "\"$(cat ") + _pop);
          _xifexpression = (_plus_1 + ")\" ");
        } else {
          String _pop_1 = ASTtoBash.argStack.pop();
          String _plus_2 = ((s + "\"") + _pop_1);
          _xifexpression = (_plus_2 + "\" ");
        }
        _xblockexpression = _xifexpression;
      }
      return _xblockexpression;
    };
    String _fold = IterableExtensions.<Expression, String>fold(e.getConstVector(), "echo ", _function);
    String _plus_1 = (_fold + "> ");
    String _plus_2 = (_plus_1 + f);
    String _plus_3 = (_plus_2 + "\n");
    ASTtoBash.generated_code = (_generated_code + _plus_3);
    ASTtoBash.argStack.push(f);
    ASTtoBash.env = type.FILE;
  }
  
  protected void _evalExpr(final Parenthesis e) {
    this.eval(e.getExpr());
    String _pop = ASTtoBash.argStack.pop();
    String _plus = ("(" + _pop);
    String _plus_1 = (_plus + ")");
    ASTtoBash.argStack.push(_plus_1);
  }
  
  protected void _evalFunc(final Acquire f) {
    String _newFile = this.newFile();
    String _plus = ("$folder+\"" + _newFile);
    final String s = (_plus + "\"");
    ASTtoBash.isFuncCalled.add("Acquire");
    this.eval(f.getPath());
    this.eval(f.getSep());
    this.eval(f.getHasHeader());
    final String head = ASTtoBash.argStack.pop();
    final String sep = ASTtoBash.argStack.pop();
    final String path = ASTtoBash.argStack.pop();
    String _generated_code = ASTtoBash.generated_code;
    ASTtoBash.generated_code = (_generated_code + (((((((("$(Acquire " + path) + " ") + sep) + " ") + head) + ") > ") + s) + "\n"));
    ASTtoBash.argStack.push(s);
    ASTtoBash.env = type.FILE;
  }
  
  protected void _evalFunc(final Save f) {
    ASTtoBash.isFuncCalled.add("Save");
    this.eval(f.getFilename());
    this.eval(f.getFile());
    this.eval(f.getSep());
    this.eval(f.getSaveHeader());
    this.eval(f.getSaveID());
    final String id = ASTtoBash.argStack.pop();
    final String head = ASTtoBash.argStack.pop();
    final String sep = ASTtoBash.argStack.pop();
    final String file = ASTtoBash.argStack.pop();
    final String filename = ASTtoBash.argStack.pop();
    String _generated_code = ASTtoBash.generated_code;
    ASTtoBash.generated_code = (_generated_code + (((((((((("$(Save " + filename) + " ") + file) + " ") + sep) + " ") + head) + " ") + id) + ")\n"));
  }
  
  protected void _evalFunc(final Select f) {
    String _newFile = this.newFile();
    String _plus = ("$folder+\"" + _newFile);
    final String s = (_plus + "\"");
    ASTtoBash.isFuncCalled.add("Select");
    this.eval(f.getFile());
    this.eval(f.getFeatures());
    final String features = ASTtoBash.argStack.pop();
    final String file = ASTtoBash.argStack.pop();
    String _generated_code = ASTtoBash.generated_code;
    ASTtoBash.generated_code = (_generated_code + (((((("$(Select " + file) + " ") + features) + ") > ") + s) + "\n"));
    ASTtoBash.argStack.push(s);
    ASTtoBash.env = type.FILE;
  }
  
  protected void _evalFunc(final Unselect f) {
    String _newFile = this.newFile();
    String _plus = ("$folder+\"" + _newFile);
    final String s = (_plus + "\"");
    ASTtoBash.isFuncCalled.add("Unselect");
    this.eval(f.getFile());
    this.eval(f.getFeatures());
    final String features = ASTtoBash.argStack.pop();
    final String file = ASTtoBash.argStack.pop();
    String _generated_code = ASTtoBash.generated_code;
    ASTtoBash.generated_code = (_generated_code + (((((("$(Unelect " + file) + " ") + features) + ") > ") + s) + "\n"));
    ASTtoBash.argStack.push(s);
    ASTtoBash.env = type.FILE;
  }
  
  protected void _evalFunc(final Filter f) {
    String _newFile = this.newFile();
    String _plus = ("$folder+\"" + _newFile);
    final String s = (_plus + "\"");
    ASTtoBash.isFuncCalled.add("Filter");
    this.eval(f.getFile());
    this.eval(f.getCond());
    final String cond = ASTtoBash.argStack.pop();
    final String file = ASTtoBash.argStack.pop();
    String _generated_code = ASTtoBash.generated_code;
    ASTtoBash.generated_code = (_generated_code + (((((("$(Filter " + file) + " ") + cond) + ") > ") + s) + "\n"));
    ASTtoBash.argStack.push(s);
    ASTtoBash.env = type.FILE;
  }
  
  protected void _evalFunc(final Mean f) {
    final String s = this.newFile();
    ASTtoBash.isFuncCalled.add("Mean");
    this.eval(f.getVector());
    final String vector = ASTtoBash.argStack.pop();
    String _generated_code = ASTtoBash.generated_code;
    ASTtoBash.generated_code = (_generated_code + ((((s + "=$(Mean ") + vector) + ")") + "\n"));
    ASTtoBash.argStack.push(s);
    ASTtoBash.env = type.VAR;
  }
  
  protected void _evalFunc(final Sum f) {
    final String s = this.newFile();
    ASTtoBash.isFuncCalled.add("Sum");
    this.eval(f.getVector());
    final String vector = ASTtoBash.argStack.pop();
    String _generated_code = ASTtoBash.generated_code;
    ASTtoBash.generated_code = (_generated_code + ((((s + "=$(Sum ") + vector) + ")") + "\n"));
    ASTtoBash.argStack.push(s);
    ASTtoBash.env = type.VAR;
  }
  
  protected void _evalFunc(final Product f) {
    final String s = this.newFile();
    ASTtoBash.isFuncCalled.add("Product");
    this.eval(f.getVector());
    final String vector = ASTtoBash.argStack.pop();
    String _generated_code = ASTtoBash.generated_code;
    ASTtoBash.generated_code = (_generated_code + ((((s + "=$(Product ") + vector) + ")") + "\n"));
    ASTtoBash.argStack.push(s);
    ASTtoBash.env = type.VAR;
  }
  
  protected void _evalFunc(final Count f) {
    final String s = this.newFile();
    ASTtoBash.isFuncCalled.add("Count");
    this.eval(f.getVector());
    final String vector = ASTtoBash.argStack.pop();
    String _generated_code = ASTtoBash.generated_code;
    ASTtoBash.generated_code = (_generated_code + ((((s + "=$(Count ") + vector) + ")") + "\n"));
    ASTtoBash.argStack.push(s);
    ASTtoBash.env = type.VAR;
  }
  
  protected void _evalFunc(final Column f) {
    String _newFile = this.newFile();
    String _plus = ("$folder+\"" + _newFile);
    final String s = (_plus + "\"");
    ASTtoBash.isFuncCalled.add("Column");
    this.eval(f.getFile());
    this.eval(f.getColumnName());
    this.eval(f.getVector());
    final String vector = ASTtoBash.argStack.pop();
    final String colname = ASTtoBash.argStack.pop();
    final String file = ASTtoBash.argStack.pop();
    String _generated_code = ASTtoBash.generated_code;
    ASTtoBash.generated_code = (_generated_code + (((((((("$(Column " + file) + " ") + colname) + " ") + vector) + ") > ") + s) + "\n"));
    ASTtoBash.argStack.push(s);
    ASTtoBash.env = type.FILE;
  }
  
  protected void _evalFunc(final Row f) {
    String _newFile = this.newFile();
    String _plus = ("$folder+\"" + _newFile);
    final String s = (_plus + "\"");
    ASTtoBash.isFuncCalled.add("Row");
    this.eval(f.getFile());
    this.eval(f.getVector());
    final String vector = ASTtoBash.argStack.pop();
    final String file = ASTtoBash.argStack.pop();
    String _generated_code = ASTtoBash.generated_code;
    ASTtoBash.generated_code = (_generated_code + (((((("$(Row " + file) + " ") + vector) + ") > ") + s) + "\n"));
    ASTtoBash.argStack.push(s);
    ASTtoBash.env = type.FILE;
  }
  
  protected void _evalFunc(final Features f) {
    String _newFile = this.newFile();
    String _plus = ("$folder+\"" + _newFile);
    final String s = (_plus + "\"");
    ASTtoBash.isFuncCalled.add("Features");
    this.eval(f.getFile());
    final String file = ASTtoBash.argStack.pop();
    String _generated_code = ASTtoBash.generated_code;
    ASTtoBash.generated_code = (_generated_code + (((("$(Features " + file) + ") > ") + s) + "\n"));
    ASTtoBash.argStack.push(s);
    ASTtoBash.env = type.FILE;
  }
  
  protected void _evalFunc(final Print f) {
    this.eval(f.getExpr());
    final String expr = ASTtoBash.argStack.pop();
    boolean _equals = ASTtoBash.env.equals(type.FILE);
    if (_equals) {
      String _generated_code = ASTtoBash.generated_code;
      ASTtoBash.generated_code = (_generated_code + (("cat $" + expr) + "\n"));
    } else {
      String _generated_code_1 = ASTtoBash.generated_code;
      ASTtoBash.generated_code = (_generated_code_1 + (("echo $" + expr) + "\n"));
    }
  }
  
  protected void _evalFunc(final Dim f) {
    String _newFile = this.newFile();
    String _plus = ("$folder+\"" + _newFile);
    final String s = (_plus + "\"");
    ASTtoBash.isFuncCalled.add("Dim");
    this.eval(f.getExpr());
    final String file = ASTtoBash.argStack.pop();
    String _generated_code = ASTtoBash.generated_code;
    ASTtoBash.generated_code = (_generated_code + (((("$(Dim " + file) + ") > ") + s) + "\n"));
    ASTtoBash.argStack.push(s);
    ASTtoBash.env = type.FILE;
  }
  
  protected void _evalFunc(final Sort f) {
    String _newFile = this.newFile();
    String _plus = ("$folder+\"" + _newFile);
    final String s = (_plus + "\"");
    ASTtoBash.isFuncCalled.add("Sort");
    this.eval(f.getCriterion());
    final String crit = ASTtoBash.argStack.pop();
    String _generated_code = ASTtoBash.generated_code;
    ASTtoBash.generated_code = (_generated_code + (((("$(Sort " + crit) + ") > ") + s) + "\n"));
    ASTtoBash.argStack.push(s);
    ASTtoBash.env = type.FILE;
  }
  
  public String implemFunction() {
    final Function2<String, String, String> _function = (String s, String x) -> {
      String _switchResult = null;
      if (x != null) {
        switch (x) {
          case "multVI":
            _switchResult = "multVI() {\necho \"le dauphin\"\n}";
            break;
          case "addVI":
            _switchResult = "addVI() {\necho \"le dauphin\"\n}";
            break;
          case "Acquire":
            _switchResult = "Acquire() {\n #c\'est acquire \n}";
            break;
          case "Save":
            _switchResult = "Save() {\n #c\'est save \n}";
            break;
          case "Select":
            _switchResult = "Select() {\n #c\'est select \n}";
            break;
          case "Unselect":
            _switchResult = "Unselect() {\n #c\'est unselect \n}";
            break;
          case "Filter":
            _switchResult = "Filter() {\n #c\'est filter \n}";
            break;
          case "Sum":
            _switchResult = "Sum() {\n sum=0\na=$(cat $1)\nfor i in \"${a[@]}\"; do\n\t sum=$((sum+i))\ndone\necho $sum\n}";
            break;
          case "Mean":
            _switchResult = "Mean() {\n sum=0\na=$(cat $1)\nb=${#b[@]}\nfor i in ${a[@]}; do\n\tsum=$((sum+i))\ndone\necho $((sum/b))\n}";
            break;
          case "Product":
            _switchResult = "Product() {\n #c\'est product \n}";
            break;
          case "Column":
            _switchResult = "Column() {\n #c\'est column \n}";
            break;
          case "Row":
            _switchResult = "Row() {\n #c\'est row \n}";
            break;
          case "Features":
            _switchResult = "Features() {\n #c\'est features \n}";
            break;
          case "Print":
            _switchResult = "Print() {\n #c\'est print \n}";
            break;
          case "Dim":
            _switchResult = "Dim() {\n #c\'est dim \n}";
            break;
          case "Sort":
            _switchResult = "Sort() {\n #c\'est sort \n}";
            break;
          case "Count":
            _switchResult = "Count() {\n #c\'est count \n}";
            break;
        }
      }
      String _plus = (s + _switchResult);
      return (_plus + "\n");
    };
    return IterableExtensions.<String, String>fold(ASTtoBash.isFuncCalled, "", _function);
  }
  
  public void evalExpr(final BaseExpression e) {
    if (e instanceof ConstNat) {
      _evalExpr((ConstNat)e);
      return;
    } else if (e instanceof ConstStr) {
      _evalExpr((ConstStr)e);
      return;
    } else if (e instanceof ConstVector) {
      _evalExpr((ConstVector)e);
      return;
    } else if (e instanceof Parenthesis) {
      _evalExpr((Parenthesis)e);
      return;
    } else if (e instanceof Var) {
      _evalExpr((Var)e);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(e).toString());
    }
  }
  
  public void evalFunc(final FuncCall f) {
    if (f instanceof Acquire) {
      _evalFunc((Acquire)f);
      return;
    } else if (f instanceof Column) {
      _evalFunc((Column)f);
      return;
    } else if (f instanceof Count) {
      _evalFunc((Count)f);
      return;
    } else if (f instanceof Dim) {
      _evalFunc((Dim)f);
      return;
    } else if (f instanceof Features) {
      _evalFunc((Features)f);
      return;
    } else if (f instanceof Filter) {
      _evalFunc((Filter)f);
      return;
    } else if (f instanceof Mean) {
      _evalFunc((Mean)f);
      return;
    } else if (f instanceof Print) {
      _evalFunc((Print)f);
      return;
    } else if (f instanceof Product) {
      _evalFunc((Product)f);
      return;
    } else if (f instanceof Row) {
      _evalFunc((Row)f);
      return;
    } else if (f instanceof Save) {
      _evalFunc((Save)f);
      return;
    } else if (f instanceof Select) {
      _evalFunc((Select)f);
      return;
    } else if (f instanceof Sort) {
      _evalFunc((Sort)f);
      return;
    } else if (f instanceof Sum) {
      _evalFunc((Sum)f);
      return;
    } else if (f instanceof Unselect) {
      _evalFunc((Unselect)f);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(f).toString());
    }
  }
}
