package fr.irisa.generator

import fr.irisa.dslCsv.Acquire
import fr.irisa.dslCsv.ArithExpression
import fr.irisa.dslCsv.Assign
import fr.irisa.dslCsv.Column
import fr.irisa.dslCsv.CompExpression
import fr.irisa.dslCsv.ConstNat
import fr.irisa.dslCsv.ConstStr
import fr.irisa.dslCsv.ConstVector
import fr.irisa.dslCsv.Count
import fr.irisa.dslCsv.Dim
import fr.irisa.dslCsv.Expression
import fr.irisa.dslCsv.Features
import fr.irisa.dslCsv.Filter
import fr.irisa.dslCsv.FuncCall
import fr.irisa.dslCsv.LogicalExpression
import fr.irisa.dslCsv.Mean
import fr.irisa.dslCsv.Nop
import fr.irisa.dslCsv.Parenthesis
import fr.irisa.dslCsv.Print
import fr.irisa.dslCsv.Product
import fr.irisa.dslCsv.Row
import fr.irisa.dslCsv.Save
import fr.irisa.dslCsv.Select
import fr.irisa.dslCsv.Sort
import fr.irisa.dslCsv.SubExpression
import fr.irisa.dslCsv.Sum
import fr.irisa.dslCsv.Unselect
import fr.irisa.dslCsv.Var
import java.util.HashMap
import java.util.HashSet
import java.util.Map
import java.util.Set
import java.util.Stack
import org.eclipse.emf.common.util.EList

enum type {
	VOID, INT, STRING, VAR, FILE, NEGATION, UNKNOWN;
}

class ASTtoBash {
	static final int FUNC_CALL_NUMBER = 15
	/**
	 * used to know wich ones of the function are used, 
	 * and need to be implemented in the compiled program 
	 */
	static Set<String> isFuncCalled = new HashSet<String>(FUNC_CALL_NUMBER)
	
	/**
	 * list of bash instructions generated by the compilation
	 */
	static String generated_header = "#!/bin/bash\nfolder=$(mktemp -d)+\"/\"\n"
	static String generated_code = "\n"
	
	
	/**
	 * keeps track of the types of variables
	 */
	static Map<String, type> symboltable = new HashMap<String, type>();
	
	/**
	 * stacks the arguments of function calls
	 */
	static Stack<String> argStack = new Stack<String>()
	
	static int file_id = 0
	static type env=type.VOID


	def<T> T pop(EList<T> l) {
		if (l.size > 0) {
			val tmp = l.get(0)
			l.remove(0)
			tmp
		} else 
			null
	}
	
	def String newFile() {
		return "csv" + (file_id++) + ".csv"
	}

// --------------------------------------------------------------------------------
	
	def String eval(EList<Expression> l) {
		l.forEach[eval]
		generated_header + implemFunction + generated_code + "\nrm -r ${folder::-1}"
	}
	
	def void eval(Expression e) {
		if (e instanceof FuncCall) {
			(e as FuncCall).evalFunc
		} else if (e instanceof Assign) {
			(e as Assign).^val.eval
			val ev = argStack.pop
			if (env.equals(type.FILE)) {
				generated_code += "echo " + ev + " > " + (e as Assign).^var + "\n"
								
			} else {				
				generated_code += (e as Assign).^var + "=" + ev + "\n"
			}
			symboltable.put((e as Assign).^var, env)	
		} else if (e instanceof LogicalExpression) {
			(e as LogicalExpression).eval
		} else if (e instanceof Nop) {
			(e as Nop).expr.eval
			if (env.equals(type.FILE)) 
				throw new TypeException(env, type.NEGATION)
			argStack.push("$[ ! " + argStack.pop + " ]")
		}
		
	}
	
	def void eval(LogicalExpression e) {
		e.left.eval
		if (e.op !== null) {
			val t1 = env
			e.right.eval
			val t2 = env

			//TODO selon type
			if (! t1.equals(t2))
				throw new TypeException(t1, t2)

			val r = argStack.pop
			val l = argStack.pop
			argStack.push(l+e.op+r)
		}
	}
	
	def void eval(CompExpression e) {
		e.left.eval
		if (e.op !== null) {
			val t1 = env
			e.right.eval
			val t2 = env

			//TODO selon type
			if (! t1.equals(t2))
				throw new TypeException(t1, t2)

			val r = argStack.pop
			val l = argStack.pop
			argStack.push(l+e.op+r)
		}
	}
	
	def void eval(ArithExpression e) {
		e.left.eval
		if (e.op !== null) {
			val t1 = env
			e.right.eval
			val t2 = env

			//TODO selon type
			if (! t1.equals(t2))
				throw new TypeException(t1, t2)

			val r = argStack.pop
			val l = argStack.pop
			argStack.push(l+e.op+r)
		}
	}
	
	def void eval(SubExpression e) {
		e.left.evalExpr
		if (e.op !== null) {
			val t1 = env
			e.right.eval
			val t2 = env

			//TODO selon type
			if (! t1.equals(t2))
				throw new TypeException(t1, t2)

			val r = argStack.pop
			val l = argStack.pop
			argStack.push(l+e.op+r)
		}
	}
	
	
	def dispatch void evalExpr(Var e) {
		val v = e.^var
		argStack.push(v)
		env=symboltable.get(v)
	}
	
	def dispatch void evalExpr(ConstNat e) {			
		argStack.push(String.valueOf(e.constNat))
		env=type.INT
	}
	
	def dispatch void evalExpr(ConstStr e) {
		argStack.push(e.constStr)
		env=type.STRING
	}
	
	def dispatch void evalExpr(ConstVector e) {
		val f = "$folder+\"" + newFile() + "\""
		generated_code += e.constVector.fold("echo ", [ s,x | 
			x.eval;
			if (env.equals(type.FILE)) {
				s + "\"$(cat " + argStack.pop + ")\" " 
			} else  s + "\"" + argStack.pop + "\" " 
		]) + "> " + f 
		argStack.push(f)
		env = type.FILE
	}
	
	def dispatch void evalExpr(Parenthesis e) {
		e.expr.eval
		argStack.push('(' + argStack.pop + ')')
	}
	
	def dispatch void evalFunc(Acquire f) {
		val s = "$folder+\"" + newFile() + "\""
		isFuncCalled.add("Acquire")
		
		f.path.eval()
		f.sep.eval()
		f.hasHeader.eval()
		
		val head = argStack.pop
		val sep  = argStack.pop
		val path = argStack.pop
		//TODO faut-il vraiment charger un fichier dans un autre ?
		//TODO ajouter maps d'info fichios
		generated_code += "$(Acquire " + path + " " + sep + " " + head + ") > " + s + "\n"
		
		argStack.push(s)
		env = type.FILE
	}
	
	def dispatch void evalFunc(Save f) {
		isFuncCalled.add("Save")
		
		f.filename.eval()
		f.file.eval()
		f.sep.eval()
		f.saveHeader.eval()
		f.saveID.eval()
		
		val id		= argStack.pop
		val head	= argStack.pop
		val sep  	= argStack.pop
		val file 	= argStack.pop
		val filename = argStack.pop
		
		
		generated_code += "$(Save " + filename + " " + file + " " 
			+ sep + " " + head + " " + id + ")\n"		
	}
	
	def dispatch void evalFunc(Select f) {
		val s = "$folder+\"" + newFile() + "\""
		isFuncCalled.add("Select")
		
		f.file.eval()
		f.features.eval()
		
		val features = argStack.pop
		val file     = argStack.pop
		
		generated_code += "$(Select " + file + " " + features + ") > " + s + "\n"
		
		argStack.push(s)
		env = type.FILE
	}
	
	def dispatch void evalFunc(Unselect f) {
		val s = "$folder+\"" + newFile() + "\""
		isFuncCalled.add("Unselect")
		
		f.file.eval()
		f.features.eval()
		
		val features = argStack.pop
		val file     = argStack.pop
		
		generated_code += "$(Unelect " + file + " " + features + ") > " + s + "\n"	
		
		argStack.push(s)
		env = type.FILE
	}
	
	def dispatch void evalFunc(Filter f) {
		val s = "$folder+\"" + newFile() + "\""
		isFuncCalled.add("Filter")
		
		f.file.eval()
		f.cond.eval()
		
		val cond = argStack.pop
		val file = argStack.pop
		
		generated_code += "$(Filter " + file + " " + cond + ") > " + s + "\n"
		
		argStack.push(s)
		env = type.FILE
	}
	
	def dispatch void evalFunc(Mean f) {
		val s = newFile()
		isFuncCalled.add("Mean")
		
		f.vector.eval()
		
		val vector = argStack.pop
		
		generated_code += s + "=$(Mean " + vector + ")"	 + "\n"
		
		argStack.push(s)
		env = type.VAR
	}
	
	def dispatch void evalFunc(Sum f) {
		val s = newFile()
		isFuncCalled.add("Sum")
		
		f.vector.eval()
		
		val vector = argStack.pop
		
		generated_code += s + "=$(Sum " + vector + ")" + "\n"
		
		argStack.push(s)
		env = type.VAR
	}
	
	def dispatch void evalFunc(Product f) {
		val s = newFile()
		isFuncCalled.add("Product")
		
		f.vector.eval()
		
		val vector = argStack.pop
		
		generated_code += s + "=$(Product " + vector + ")" + "\n"	
		
		argStack.push(s)
		env = type.VAR
	}
	
	def dispatch void evalFunc(Count f) {
		val s = newFile()
		isFuncCalled.add("Count")
		
		f.vector.eval()
		
		val vector = argStack.pop
		
		generated_code += s + "=$(Count " + vector + ")" + "\n"	
		
		argStack.push(s)
		env = type.VAR
	}
	
	def dispatch void evalFunc(Column f) {
		val s = "$folder+\"" + newFile() + "\""
		isFuncCalled.add("Column")
		
		f.file.eval()
		f.columnName.eval()
		f.vector.eval()
		
		val vector = argStack.pop
		val colname = argStack.pop
		val file = argStack.pop
		
		generated_code += "$(Column " + file + " " + colname + " " + vector + ") > " + s + "\n"	
		
		argStack.push(s)
		env = type.FILE
	}
	
	def dispatch void evalFunc(Row f) {
		val s = "$folder+\"" + newFile() + "\""
		isFuncCalled.add("Row")
		
		f.file.eval()
		f.vector.eval()
		
		val vector = argStack.pop
		val file = argStack.pop
		
		generated_code += "$(Row " + file + " " + vector + ") > " + s + "\n"
		
		argStack.push(s)
		env = type.FILE
	}
	
	def dispatch void evalFunc(Features f) {
		val s = "$folder+\"" + newFile() + "\""
		isFuncCalled.add("Features")
		
		f.file.eval()
		
		val file = argStack.pop
		
		generated_code += "$(Features " + file + ") > " + s + "\n"
		
		argStack.push(s)
		env = type.FILE
	}
	
	def dispatch void evalFunc(Print f) {
		f.expr.eval()
		
		val expr = argStack.pop
		
		if (env.equals(type.FILE))
			generated_code += "cat $" + expr + "\n"
		else 
			generated_code += "echo $" + expr + "\n"
		
	}
	
	def dispatch void evalFunc(Dim f) {
		val s = "$folder+\"" + newFile() + "\""
		isFuncCalled.add("Dim")
		
		f.expr.eval()
		
		val file = argStack.pop
		
		generated_code += "$(Dim " + file + ") > " + s + "\n"
		
		argStack.push(s)
		env = type.FILE
	}
	
	def dispatch void evalFunc(Sort f) {
		val s = "$folder+\"" + newFile() + "\""
		isFuncCalled.add("Sort")
		
		f.criterion.eval()
		
		val crit = argStack.pop
		
		generated_code += "$(Sort " + crit + ") > " + s + "\n"
		
		argStack.push(s)
		env = type.FILE
	}
	
	def String implemFunction() {
		isFuncCalled.fold("", [ s, x |
			s + switch x {
				case "multVI"	: "multVI() {\necho \"le dauphin\"\n}"
				case "addVI"	: "addVI() {\necho \"le dauphin\"\n}"
				case "Acquire" 	: "Acquire() {\n #c'est acquire \n}"
				case "Save"    	: "Save() {\n #c'est save \n}"
				case "Select" 	: "Select() {\n #c'est select \n}"
				case "Unselect" : "Unselect() {\n #c'est unselect \n}"
				case "Filter"	: "Filter() {\n #c'est filter \n}"
				case "Sum" 		: "Sum() {\n sum=0\na=$(cat $1)\nfor i in \"${a[@]}\"; do\n\t sum=$((sum+i))\ndone\necho $sum\n}"
				case "Mean" 	: "Mean() {\n sum=0\na=$(cat $1)\nb=${#b[@]}\nfor i in ${a[@]}; do\n\tsum=$((sum+i))\ndone\necho $((sum/b))\n}"
				case "Product" 	: "Product() {\n #c'est product \n}"
				case "Column" 	: "Column() {\n #c'est column \n}"
				case "Row" 		: "Row() {\n #c'est row \n}"
				case "Features" : "Features() {\n #c'est features \n}"
				case "Print" 	: "Print() {\n #c'est print \n}"
				case "Dim" 		: "Dim() {\n #c'est dim \n}"
				case "Sort" 	: "Sort() {\n #c'est sort \n}"
				case "Count" 	: "Count() {\n #c'est count \n}"
			} + "\n"
		])
	}
}