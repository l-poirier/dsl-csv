package fr.irisa.generator

import fr.irisa.dslCsv.Acquire
import fr.irisa.dslCsv.ArithExpression
import fr.irisa.dslCsv.Assign
import fr.irisa.dslCsv.BaseExpression
import fr.irisa.dslCsv.Column
import fr.irisa.dslCsv.CompExpression
import fr.irisa.dslCsv.ConstNat
import fr.irisa.dslCsv.ConstStr
import fr.irisa.dslCsv.ConstVector
import fr.irisa.dslCsv.Count
import fr.irisa.dslCsv.Dim
import fr.irisa.dslCsv.Expression
import fr.irisa.dslCsv.Features
import fr.irisa.dslCsv.Filter
import fr.irisa.dslCsv.FuncCall
import fr.irisa.dslCsv.LogicalExpression
import fr.irisa.dslCsv.Mean
import fr.irisa.dslCsv.Nop
import fr.irisa.dslCsv.Parenthesis
import fr.irisa.dslCsv.Print
import fr.irisa.dslCsv.Product
import fr.irisa.dslCsv.Row
import fr.irisa.dslCsv.Save
import fr.irisa.dslCsv.Select
import fr.irisa.dslCsv.Sort
import fr.irisa.dslCsv.SubExpression
import fr.irisa.dslCsv.Sum
import fr.irisa.dslCsv.Unselect
import fr.irisa.dslCsv.Var
import java.util.HashMap
import java.util.HashSet
import java.util.Map
import java.util.Set
import org.eclipse.emf.common.util.EList

enum type {
	VOID, INT, STRING, VECTOR, VAR, UNKNOWN;
}

class ASTtoBash {
	static final int FUNC_CALL_NUMBER = 15
	/**
	 * used to know wich ones of the function are used, and need to be implemented in the compiled program 
	 */
	static Set<String> isFuncCalled = new HashSet<String>(FUNC_CALL_NUMBER)
	static Map<String, type> symboltable = new HashMap<String, type>();
	static int contextExpr=0
	static type env=type.VOID

	def type lub(type l, type r) {
		if (l.equals(r)) {
			l
		} else if (l.equals(type.VOID)) {
			r
		} else if (r.equals(type.VOID)) {
			l
		} else if (l.equals(type.INT)){
			if (r.equals(type.STRING)) {
				throw new TypeException(l, r)
			} else if (r.equals(type.VECTOR)) {
				l
			} 
		}
	}
	
	def<T> T pop(EList<T> l) {
		if (l.size > 0) {
			val tmp = l.get(0)
			l.remove(0)
			tmp
		} else 
			null
	}
	
	def String neutralized(String s) {
		s.toCharArray.fold("", [f, c | f + (c=='\\'? "\\\\":c)])
	}
	
	
	
	def String evalExpr(Expression e) {
		ASTtoBash.contextExpr ++
		var String i = "";
		if (e instanceof FuncCall) {
			i="$(" + evalFuncCall(e as FuncCall) + ")"
		} else if (e instanceof Assign) {
			i="let \"" + (e as Assign).^var + "=" + evalExpr((e as Assign).^val) + '\"'
			symboltable.put((e as Assign).^var, env)	
		} else if (e instanceof LogicalExpression) {
			i='$((' + evalMath(e as LogicalExpression) + '))'
		} else if (e instanceof Nop) {
			i='!' + evalExpr((e as Nop).expr)
		}
		
		ASTtoBash.contextExpr --
		i + (ASTtoBash.contextExpr == 0 ? "\n": "")
	}
		
	def String evalMath(LogicalExpression e) {
		
//		e.right.fold(evalMath(e.left), [s, x | s + e.op.pop + evalMath(x)])
""
	}
	
	def String evalMath(CompExpression e) {
//		e.right.fold(evalMath(e.left), [s, x | s + e.op.pop + evalMath(x)])
""
	}
	
	def String evalMath(ArithExpression e) {
//		e.right.fold(evalMath(e.left), [s, x | s + e.op.pop + evalMath(x)])
""
	}
	
	def String evalMath(SubExpression e) {
//		e.right.fold(evalMath(e.left), [s, x | s + e.op.pop + evalMath(x)])
""
	}
	
	def String evalMath(BaseExpression e) {
		//TODO
		if (e instanceof Var) {
			env=type.VAR
			"$"+(e as Var).^var
		} else if (e instanceof Parenthesis) {
			'(' + (e as Parenthesis).expr.evalExpr + ')'
			//same env as expr
		} else if (e instanceof ConstStr) {
			env=type.STRING
			"\"" + (e as ConstStr).constStr + "\""
		} else if (e instanceof ConstNat) {
			env=type.INT
			String.valueOf((e as ConstNat).constNat)
		} else if (e instanceof ConstVector) {
			env=type.VECTOR
			"( " + (e as ConstVector).constVector
				.fold("", [ s, x | s + "\", \"" + x.evalExpr])
				+ "\" )"
			
		} 
	}
	
	def String eval(EList<Expression> l) {
		val instrs = "#!/bin/bash\n" + l.fold("", [s, x | s+evalExpr(x)])
		implemFunction() + instrs
	}
	
	
	def String evalFuncCall(FuncCall f) {
		//TODO
		if (f instanceof Acquire) {
			isFuncCalled.add("Acquire")
			"Acquire " 
				+ (f as Acquire).path.evalExpr + " " 
				+ (f as Acquire).sep.evalExpr + " " 
				+ (f as Acquire).hasHeader.evalExpr
				
		} else if (f instanceof Save) {
			isFuncCalled.add("Save")
			"Save " 
				+ (f as Save).filename.evalExpr + " " 
				+ (f as Save).file.evalExpr + " " 
				+ (f as Save).sep.evalExpr + " " 
				+ (f as Save).saveHeader.evalExpr + " " 
				+ (f as Save).saveID.evalExpr
		} else if (f instanceof Select) {
			isFuncCalled.add("Select")
			"Select "
				+ (f as Select).file.evalExpr + " "
				+ (f as Select).features.evalExpr 
		} else if (f instanceof Unselect) {
			isFuncCalled.add("Unselect")
			"Unselect "
				+ (f as Unselect).file.evalExpr + " "
				+ (f as Unselect).features.evalExpr 
		} else if (f instanceof Filter) {
			isFuncCalled.add("Filter")
			"Filter "
				+ (f as Filter).file.evalExpr + " "
				+ (f as Filter).cond.evalExpr
		} else if (f instanceof Mean) {
			isFuncCalled.add("Mean")
			"Mean "
				+ (f as Mean).vector.evalExpr
		} else if (f instanceof Sum) {
			isFuncCalled.add("Sum")
			"Sum"
				+ (f as Sum).vector.evalExpr
		} else if (f instanceof Product) {
			isFuncCalled.add("Product")
			"Product"
				+ (f as Product).vector.evalExpr
		} else if (f instanceof Column) {
			isFuncCalled.add("Column")
			"Column "
				+ (f as Column).file.evalExpr + " "
				+ (f as Column).columnName.evalExpr + " "
				+ (f as Column).vector.evalExpr
		} else if (f instanceof Row) {
			isFuncCalled.add("Row")
			"Row "
				+ (f as Row).file.evalExpr + " "
				+ (f as Row).vector.evalExpr
		} else if (f instanceof Features) {
			isFuncCalled.add("Features")
			"Features "
				+ (f as Features).file.evalExpr
		} else if (f instanceof Print) {
			isFuncCalled.add("Print")
			"Print "
				+ (f as Print).expr.evalExpr
		} else if (f instanceof Dim) {
			isFuncCalled.add("Dim")
			"Dim "
				+ (f as Dim).expr.evalExpr
		} else if (f instanceof Sort) {
			isFuncCalled.add("Sort")
			"Sort "
				+ (f as Sort).file.evalExpr + " "
				+ (f as Sort).criterion.evalExpr
		} else if (f instanceof Count) {
			isFuncCalled.add("Count")
			"Count"
				+ (f as Count).vector.evalExpr
		} 
	}
	
	def String implemFunction() {
		isFuncCalled.fold("", [ s, x |
			s + switch x {
				case "Acquire" 	: "Acquire() {\n #c'est acquire \n}"
				case "Save"    	: "Save() {\n #c'est save \n}"
				case "Select" 	: "Select() {\n #c'est select \n}"
				case "Unselect" : "Unselect() {\n #c'est unselect \n}"
				case "Filter"	: "Filter() {\n #c'est filter \n}"
				case "Mean" 	: "Mean() {\n #c'est mean \n}"
				case "Sum" 		: "Sum() {\n #c'est sum \n}"
				case "Product" 	: "Product() {\n #c'est product \n}"
				case "Column" 	: "Column() {\n #c'est column \n}"
				case "Row" 		: "Row() {\n #c'est row \n}"
				case "Features" : "Features() {\n #c'est features \n}"
				case "Print" 	: "Print() {\n #c'est print \n}"
				case "Dim" 		: "Dim() {\n #c'est dim \n}"
				case "Sort" 	: "Sort() {\n #c'est sort \n}"
				case "Count" 	: "Count() {\n #c'est count \n}"
			} + "\n"
		])
	}
}